name: TODOS API - Dev Build & Deploy

on:
  push:
    branches: [ main, feat/dev/pipelines ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      REMOTE_BASE_DIR: ~/microservice-app-example
      REMOTE_SERVICE_DIR: ~/microservice-app-example/todos-api
      SSH_HOST: 128.24.80.61
      SSH_USERNAME: adminuser
      SSH_PASSWORD: YourComplexPassword123!
      SSH_PORT: 22
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check SSH reachability (port 22)
        run: |
          for i in {1..12}; do
            if timeout 5 bash -c "echo > /dev/tcp/${{ env.SSH_HOST }}/22" 2>/dev/null; then
              echo "SSH port reachable"; exit 0; fi; echo "Waiting for SSH... ($i)"; sleep 5; done; echo "SSH not reachable" >&2; exit 1

      - name: Ensure remote directory exists
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 120s
          command_timeout: 20m
          script: |
            mkdir -p ${{ env.REMOTE_BASE_DIR }}
            mkdir -p ${{ env.REMOTE_SERVICE_DIR }}

      - name: Copy compose files to remote base dir
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 120s
          source: "docker-compose*.yml"
          target: ${{ env.REMOTE_BASE_DIR }}

      - name: Copy microservices folder to remote base dir
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 180s
          source: "microservices/**"
          target: ${{ env.REMOTE_BASE_DIR }}

      - name: Copy todos-api to remote host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 120s
          source: "microservices/todos-api/**"
          target: ${{ env.REMOTE_SERVICE_DIR }}
          strip_components: 2

      - name: Build and restart todos-api with Docker Compose
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 180s
          command_timeout: 30m
          script: |
            set -euo pipefail
            echo "Reconstruyendo y levantando todos-api vía Docker Compose"
            cd ${{ env.REMOTE_BASE_DIR }}
            
            # Stop and remove all containers using port 6379 (Redis port)
            echo "Deteniendo contenedores que usan el puerto 6379..."
            CONTAINERS_USING_PORT=$(docker ps -q --filter "publish=6379" || true)
            if [ -n "$CONTAINERS_USING_PORT" ]; then
              echo "Deteniendo contenedores: $CONTAINERS_USING_PORT"
              docker stop $CONTAINERS_USING_PORT || true
              docker rm $CONTAINERS_USING_PORT || true
            fi
            
            # Also check for containers with port mapping to 6379
            CONTAINERS_WITH_REDIS_PORT=$(docker ps -q --filter "expose=6379" || true)
            if [ -n "$CONTAINERS_WITH_REDIS_PORT" ]; then
              echo "Deteniendo contenedores con puerto 6379 expuesto: $CONTAINERS_WITH_REDIS_PORT"
              docker stop $CONTAINERS_WITH_REDIS_PORT || true
              docker rm $CONTAINERS_WITH_REDIS_PORT || true
            fi
            
            # Stop and remove all containers using port 8082 (todos-api port)
            echo "Deteniendo contenedores que usan el puerto 8082..."
            CONTAINERS_USING_TODOS_PORT=$(docker ps -q --filter "publish=8082" || true)
            if [ -n "$CONTAINERS_USING_TODOS_PORT" ]; then
              echo "Deteniendo contenedores: $CONTAINERS_USING_TODOS_PORT"
              docker stop $CONTAINERS_USING_TODOS_PORT || true
              docker rm $CONTAINERS_USING_TODOS_PORT || true
            fi
            
            # Also check for containers with port mapping to 8082
            CONTAINERS_WITH_TODOS_PORT=$(docker ps -q --filter "expose=8082" || true)
            if [ -n "$CONTAINERS_WITH_TODOS_PORT" ]; then
              echo "Deteniendo contenedores con puerto 8082 expuesto: $CONTAINERS_WITH_TODOS_PORT"
              docker stop $CONTAINERS_WITH_TODOS_PORT || true
              docker rm $CONTAINERS_WITH_TODOS_PORT || true
            fi
            
            # Additional cleanup: find and stop any container that might be using ports 6379 or 8082
            echo "Búsqueda adicional de contenedores usando puertos 6379 y 8082..."
            ALL_CONTAINERS=$(docker ps -aq || true)
            if [ -n "$ALL_CONTAINERS" ]; then
              for container in $ALL_CONTAINERS; do
                # Check if container is using port 6379 or 8082
                if docker port "$container" 2>/dev/null | grep -q "6379\|8082"; then
                  echo "Deteniendo contenedor $container que usa puerto 6379 o 8082"
                  docker stop "$container" || true
                  docker rm "$container" || true
                fi
              done
            fi
            
            # Clean up any existing compose containers
            echo "Limpiando contenedores de compose existentes..."
            docker-compose -f docker-compose.yml down --remove-orphans || true
            docker-compose -f docker-compose.yml rm -fsv || true
            
            # Check if ports 6379 and 8082 are still in use after cleanup
            echo "Verificando disponibilidad de los puertos 6379 y 8082..."
            if command -v netstat >/dev/null 2>&1; then
              if netstat -tuln | grep -q ":6379 "; then
                echo "ADVERTENCIA: El puerto 6379 aún está en uso después de la limpieza"
                netstat -tuln | grep ":6379 " || true
              else
                echo "Puerto 6379 disponible"
              fi
              if netstat -tuln | grep -q ":8082 "; then
                echo "ADVERTENCIA: El puerto 8082 aún está en uso después de la limpieza"
                netstat -tuln | grep ":8082 " || true
              else
                echo "Puerto 8082 disponible"
              fi
            elif command -v ss >/dev/null 2>&1; then
              if ss -tuln | grep -q ":6379 "; then
                echo "ADVERTENCIA: El puerto 6379 aún está en uso después de la limpieza"
                ss -tuln | grep ":6379 " || true
              else
                echo "Puerto 6379 disponible"
              fi
              if ss -tuln | grep -q ":8082 "; then
                echo "ADVERTENCIA: El puerto 8082 aún está en uso después de la limpieza"
                ss -tuln | grep ":8082 " || true
              else
                echo "Puerto 8082 disponible"
              fi
            fi
            
            # Build the todos-api service
            echo "Construyendo todos-api..."
            docker-compose -f docker-compose.yml build todos-api
            
            # Start the services
            echo "Iniciando servicios..."
            docker-compose -f docker-compose.yml up -d --force-recreate todos-api redis
            
            # Wait a moment for services to start
            sleep 10
            
            # Verify todos-api is running
            CID=$(docker-compose ps -q todos-api || true)
            if [ -z "$CID" ]; then
              echo "No se encontró el contenedor todos-api" >&2
              exit 1
            fi
            RUNNING=$(docker inspect -f '{{.State.Running}}' "$CID")
            if [ "$RUNNING" != "true" ]; then
              echo "El contenedor todos-api no está en ejecución" >&2
              docker logs "$CID" || true
              exit 1
            fi
            
            # Verify Redis is running
            REDIS_CID=$(docker-compose ps -q redis || true)
            if [ -z "$REDIS_CID" ]; then
              echo "No se encontró el contenedor redis" >&2
              exit 1
            fi
            REDIS_RUNNING=$(docker inspect -f '{{.State.Running}}' "$REDIS_CID")
            if [ "$REDIS_RUNNING" != "true" ]; then
              echo "El contenedor redis no está en ejecución" >&2
              docker logs "$REDIS_CID" || true
              exit 1
            fi
            
            echo "todos-api y redis desplegados correctamente"
