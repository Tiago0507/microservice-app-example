name: Users API - Dev Build & Deploy

on:
  push:
    branches: [ main, feat/dev/pipelines ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      REMOTE_BASE_DIR: ~/microservice-app-example
      REMOTE_SERVICE_DIR: ~/microservice-app-example/users-api
      SSH_HOST: 128.24.80.61
      SSH_USERNAME: adminuser
      SSH_PASSWORD: YourComplexPassword123!
      SSH_PORT: 22
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check SSH reachability (port 22)
        run: |
          for i in {1..12}; do
            if timeout 5 bash -c "echo > /dev/tcp/${{ env.SSH_HOST }}/22" 2>/dev/null; then
              echo "SSH port reachable"; exit 0; fi; echo "Waiting for SSH... ($i)"; sleep 5; done; echo "SSH not reachable" >&2; exit 1

      - name: Ensure remote directory exists
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 120s
          command_timeout: 20m
          script: |
            mkdir -p ${{ env.REMOTE_BASE_DIR }}
            mkdir -p ${{ env.REMOTE_SERVICE_DIR }}

      - name: Copy compose files to remote base dir
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 120s
          source: "docker-compose*.yml"
          target: ${{ env.REMOTE_BASE_DIR }}

      - name: Copy microservices folder to remote base dir
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 180s
          source: "microservices/**"
          target: ${{ env.REMOTE_BASE_DIR }}

      - name: Copy users-api to remote host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 120s
          source: "microservices/users-api/**"
          target: ${{ env.REMOTE_SERVICE_DIR }}
          strip_components: 2

      - name: Build and restart users-api with Docker Compose
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USERNAME }}
          password: ${{ env.SSH_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          timeout: 180s
          command_timeout: 30m
          script: |
            set -euo pipefail
            echo "Reconstruyendo y levantando users-api vía Docker Compose"
            cd ${{ env.REMOTE_BASE_DIR }}
            
            # Stop and remove all containers using port 8083 (users-api port)
            echo "Deteniendo contenedores que usan el puerto 8083..."
            CONTAINERS_USING_PORT=$(docker ps -q --filter "publish=8083" || true)
            if [ -n "$CONTAINERS_USING_PORT" ]; then
              echo "Deteniendo contenedores: $CONTAINERS_USING_PORT"
              docker stop $CONTAINERS_USING_PORT || true
              docker rm $CONTAINERS_USING_PORT || true
            fi
            
            # Also check for containers with port mapping to 8083
            CONTAINERS_WITH_USERS_PORT=$(docker ps -q --filter "expose=8083" || true)
            if [ -n "$CONTAINERS_WITH_USERS_PORT" ]; then
              echo "Deteniendo contenedores con puerto 8083 expuesto: $CONTAINERS_WITH_USERS_PORT"
              docker stop $CONTAINERS_WITH_USERS_PORT || true
              docker rm $CONTAINERS_WITH_USERS_PORT || true
            fi
            
            # Additional cleanup: find and stop any container that might be using port 8083
            echo "Búsqueda adicional de contenedores usando puerto 8083..."
            ALL_CONTAINERS=$(docker ps -aq || true)
            if [ -n "$ALL_CONTAINERS" ]; then
              for container in $ALL_CONTAINERS; do
                # Check if container is using port 8083
                if docker port "$container" 2>/dev/null | grep -q "8083"; then
                  echo "Deteniendo contenedor $container que usa puerto 8083"
                  docker stop "$container" || true
                  docker rm "$container" || true
                fi
              done
            fi
            
            # Aggressive Docker cleanup to fix ContainerConfig errors
            echo "Limpieza agresiva de Docker para resolver errores de ContainerConfig..."
            
            # Stop all running containers
            docker stop $(docker ps -aq) 2>/dev/null || true
            
            # Remove all containers
            docker rm -f $(docker ps -aq) 2>/dev/null || true
            
            # Remove all networks
            docker network rm $(docker network ls -q) 2>/dev/null || true
            
            # Remove all volumes
            docker volume rm $(docker volume ls -q) 2>/dev/null || true
            
            # Remove all images
            docker rmi -f $(docker images -q) 2>/dev/null || true
            
            # Clean up Docker system completely
            docker system prune -a --volumes -f || true
            
            # Restart Docker daemon to clear any corrupted state
            echo "Reiniciando daemon de Docker para limpiar estado corrupto..."
            sudo systemctl restart docker || true
            sleep 15
            
            # Verify Docker is working
            docker info || { echo "Docker no responde, reintentando..."; sleep 10; docker info; }
            
            # Check if port 8083 is still in use after cleanup
            echo "Verificando disponibilidad del puerto 8083..."
            if command -v netstat >/dev/null 2>&1; then
              if netstat -tuln | grep -q ":8083 "; then
                echo "ADVERTENCIA: El puerto 8083 aún está en uso después de la limpieza"
                netstat -tuln | grep ":8083 " || true
              else
                echo "Puerto 8083 disponible"
              fi
            elif command -v ss >/dev/null 2>&1; then
              if ss -tuln | grep -q ":8083 "; then
                echo "ADVERTENCIA: El puerto 8083 aún está en uso después de la limpieza"
                ss -tuln | grep ":8083 " || true
              else
                echo "Puerto 8083 disponible"
              fi
            fi
            
            # Restart Docker daemon if needed (this helps with ContainerConfig errors)
            echo "Verificando estado del daemon de Docker..."
            if ! docker info >/dev/null 2>&1; then
              echo "Reiniciando daemon de Docker..."
              sudo systemctl restart docker || true
              sleep 10
            fi
            
            # Build the users-api service
            echo "Construyendo users-api..."
            DOCKER_BUILDKIT=0 COMPOSE_DOCKER_CLI_BUILD=0 docker-compose -f docker-compose.yml build --no-cache users-api
            
            # Start the service using a different approach to avoid ContainerConfig errors
            echo "Iniciando users-api con estrategia alternativa..."
            
            # First, create the network manually
            docker network create microservice-app-example_microservices-net 2>/dev/null || true
            
            # Start services one by one to avoid ContainerConfig issues
            echo "Iniciando Redis primero..."
            docker-compose -f docker-compose.yml up -d redis
            
            # Wait for Redis to be ready
            sleep 10
            
            echo "Iniciando users-api..."
            docker-compose -f docker-compose.yml up -d users-api
            
            # Wait a moment for service to start
            sleep 10
            
            # Verify users-api is running
            CID=$(docker-compose ps -q users-api || true)
            if [ -z "$CID" ]; then
              echo "No se encontró el contenedor users-api" >&2
              exit 1
            fi
            RUNNING=$(docker inspect -f '{{.State.Running}}' "$CID")
            if [ "$RUNNING" != "true" ]; then
              echo "El contenedor users-api no está en ejecución" >&2
              docker logs "$CID" || true
              exit 1
            fi
            echo "users-api desplegado correctamente"